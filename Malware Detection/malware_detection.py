# -*- coding: utf-8 -*-
"""EDA_Malware_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yEHJ4gkF3yEhdO2oQhxuZg_oR_NgjnlC

### Checking the Data
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import lightgbm as lgb
from sklearn.metrics import confusion_matrix, roc_auc_score ,roc_curve,auc

pd.set_option('display.max_columns', 500)
sns.set(font_scale=2)

from google.colab import drive
drive.mount('/content/gdrive')

cd gdrive/My Drive/Colab Notebooks/malwaredetection

path=""

dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'category',
        'IsSxsPassiveMode':                                     'category',
        'DefaultBrowsersIdentifier':                            'category',
        'AVProductStatesIdentifier':                            'category',
        'AVProductsInstalled':                                  'float32',
        'AVProductsEnabled':                                    'category',
        'HasTpm':                                               'category',
        'CountryIdentifier':                                    'category',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'category',
        'GeoNameIdentifier':                                    'category',
        'LocaleEnglishNameIdentifier':                          'category',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'category',
        'OsSuite':                                              'category',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'category',
        'AutoSampleOptIn':                                      'category',
        'PuaMode':                                              'category',
        'SMode':                                                'category',
        'IeVerIdentifier':                                      'category',
        'SmartScreen':                                          'category',
        'Firewall':                                             'category',
        'UacLuaenable':                                         'category',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'category',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float32',
        'Census_ProcessorManufacturerIdentifier':               'category',
        'Census_ProcessorModelIdentifier':                      'category',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'category',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float32',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'category',
        'Census_OSBuildRevision':                               'category',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'category',
        'Census_OSUILocaleIdentifier':                          'category',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'category',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'category',
        'Census_IsFlightsDisabled':                             'category',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'category',
        'Census_FirmwareManufacturerIdentifier':                'category',
        'Census_FirmwareVersionIdentifier':                     'category',
        'Census_IsSecureBootEnabled':                           'category',
        'Census_IsWIMBootEnabled':                              'category',
        'Census_IsVirtualDevice':                               'category',
        'Census_IsTouchEnabled':                                'category',
        'Census_IsPenCapable':                                  'category',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'category',
        'Wdft_IsGamer':                                         'category',
        'Wdft_RegionIdentifier':                                'category',
        'HasDetections':                                        'int8'
        }

train = pd.read_csv(path + "train.csv", dtype=dtypes)
test = pd.read_csv(path + "test.csv", dtype=dtypes)

stats = []
for col in train.columns:
    stats.append((col, train[col].nunique(), train[col].isnull().sum() * 100 / train.shape[0], train[col].value_counts(normalize=True, dropna=False).values[0] * 100, train[col].dtype))
    
stats_df = pd.DataFrame(stats, columns=['Feature', 'Unique_values', 'Percentage of missing values', 'Percentage of values in the biggest category', 'type'])
pd.set_option("display.max_rows", None, "display.max_columns", None)
stats_df.sort_values('Percentage of missing values', ascending=False).head(83)

"""We can drop the following columns:

Columns with more than 90% data with missing values : PuaMode, Census_ProcessorClass, DefaultBrowsersIdentifier 	

Columns with only one unique value in them: Census_IsFlightingInternal	,Census_IsWIMBootEnabled
"""

column = train.columns
numeric_cols = train._get_numeric_data().columns
categorical_cols = list(set(column) - set(numeric_cols))

print("Number of Categorical columns:",len(categorical_cols))
print("Number of Numeric columns:", len(numeric_cols))

"""### Dropping unnecessary features - null/single value dominated columns"""

if(len(train)==train.MachineIdentifier.nunique()):
  print(True)
else:
  print(False)

"""Since MachineIdentifier is a unique key, we can drop it."""

print(train['HasDetections'].value_counts())

sns.countplot(x="HasDetections", data=train)

"""Our Target value is very imbalanced. So we'll have to take care of this either using SMOTE or K-fold stratification or both, while training the model."""

train.IsBeta.value_counts()

"""Since most of isBeta is the same value, it doesn't make sense to keep it."""

train.Census_IsFlightsDisabled.value_counts()

"""Even for Census_IsFlightsDisabled, most of the data is the same value."""

train.AutoSampleOptIn.value_counts()

"""Even for AutoSampleOptIn, most of the data is the same value."""

train.Census_OSArchitecture.value_counts()

train.Processor.value_counts()

"""Since Processor and Census_OSArchitecture has similar values, we can drop one of them ( We decided to drop Census_OSArchitecture)"""

train.CityIdentifier.nunique()

"""Since, CityIdentifier has many unique values and it would be difficult to group or categorize these values -- we are dropping this column."""

train.Census_InternalBatteryNumberOfCharges.value_counts(normalize=True, dropna=False).cumsum().head()

train.Census_InternalBatteryType.value_counts(normalize=True, dropna=False).cumsum().head()

"""For both Census_InternalBatteryNumberOfCharges and Census_InternalBatteryType, we are not sure how battery related information would help us detect malware. So it will be dropped. 
Census_InternalBatteryNumberOfCharges may help us predict the age of the computer which may or may not help us. We may drop this later if this doesnt add any value


"""

train.Census_OSSkuName.value_counts(normalize=True, dropna=False).cumsum().head()

train.Census_OSEdition.value_counts(normalize=True, dropna=False).cumsum().head()

"""Since Census_OSSkuName and Census_OSEdition has effectively the same data in it, we will avoid redundancy and drop Census_OSSkuName

### Visualization - plotting and analyzing different columns and the values in the dataset
"""

train.Census_TotalPhysicalRAM.value_counts(normalize='True').cumsum().head(10)

"""Instead of converting the values with lower count into the same category, we can divide them into buckets. Most of the sizes do not make sense and can also be errors. The ramsizes can thus, be mapped to the nearest bucket value as follows: (512,1024,2048,4096,8192,16*1024,32*1024,65536)"""

train.Census_ProcessorCoreCount.value_counts(normalize=True).cumsum()

"""Instead of converting the values with lower count into the same category, we can divide them into buckets. The processor_counts can thus, be mapped to the nearest bucket value as follows: (1,2,4,8,16,32)"""

train.Census_InternalPrimaryDisplayResolutionHorizontal.value_counts(normalize=True).cumsum().head(10)

train.Census_InternalPrimaryDisplayResolutionVertical.value_counts(normalize=True).cumsum().head(10)

"""Instead of converting the values with lower count into the same category, we can divide them into buckets. The Resolution can thus, be mapped to the nearest bucket value as follows:
Horizontal: (1024,1280,1366,1440,1600,1920,2560,3440) 
Vertical: (540,768,900,1080,1200,1440,2048)
"""

def plot_category_percent_of_target(df, col, numberToShow=20):
    fig, ax = plt.subplots(1, 1, figsize=(12,8))
    cat_percent = df[[col, 'HasDetections']].groupby(col, as_index=False).mean()
    cat_size = df[col].value_counts().reset_index(drop=False)
    cat_size.columns = [col, 'count']
    cat_percent = cat_percent.merge(cat_size, on=col, how='left')
    cat_percent['HasDetections'] = cat_percent['HasDetections'].fillna(0)
    cat_percent = cat_percent.sort_values(by='count', ascending=False)[:numberToShow]
    sns.barplot(ax=ax, x='HasDetections', y=col, data=cat_percent, order=cat_percent[col])

    for i, p in enumerate(ax.patches):
        ax.annotate('{}'.format(cat_percent['count'].values[i]), (p.get_width(), p.get_y()+0.5), fontsize=20)

    plt.xlabel('% of HasDetections(target)')
    plt.ylabel(col)
    plt.show()

plot_category_percent_of_target(train, 'ProductName')

"""The figure shows the percentage of hasDetections for each category of the feature ProductName. It also shows the total count of different categories. 


Since there are categories with very low count, we can merge them together and create a new category called "OTHER"

**Product Name**:Categorical,Unbalanced,0% null values, Not dropping it.
"""

plot_category_percent_of_target(train, 'EngineVersion')

train.EngineVersion.value_counts(normalize=True).head(10)

"""The values start from 1.1.X.X but we can extract the third and the fourth part of the string to get more features. 
Since many categories have a low count, we can combine those together and categorise as "OTHER"

"""

plot_category_percent_of_target(train, 'RtpStateBitfield')

"""We can categorize this column, and all the categories with low count along with null values are together put into one category called "OTHER""""

plot_category_percent_of_target(train, 'IsSxsPassiveMode')

"""IsSxsPassiveMode has no null values and we can convert its dtype to category. No other change is needed."""

train['AVProductsInstalled'].value_counts()

"""Again, for this feature,we change the dtype to "category" and categories with lower count are combined together into one category called "other""""

plot_category_percent_of_target(train, 'AVProductsEnabled')

"""AVProductsEnabled : converted to "Category" type and then categories with low count are all grouped together into "other""""

plot_category_percent_of_target(train, 'HasTpm')

train.HasTpm.isnull().sum()

"""There are no null values. No changes needed."""

plot_category_percent_of_target(train, 'Platform')

train.Platform.isnull().sum()

"""There are no null values. No changes needed. """

plot_category_percent_of_target(train, 'Processor')

"""Processor :arm64 has very low number of detections. It has no null values"""

plot_category_percent_of_target(train, 'OsVer')

"""OsVersion: categories with count lower than 1000 are all grouped together into "other""""

plot_category_percent_of_target(train, 'OsBuild')

train.OsBuild.value_counts().head()

"""OsBuild : converted to "Category" type and then categories with count lower than 10,000 are all grouped together into "other". It has no null values"""

plot_category_percent_of_target(train, 'OsSuite')

"""OsSuite : converted to "Category" type and then categories with count lower than 10,000 are all grouped together into "other". No null values."""

plot_category_percent_of_target(train, 'OsPlatformSubRelease')

"""No changes needed."""

plot_category_percent_of_target(train, 'OsBuildLab')

"""We can create a new feature by extracting the first and second part of the category name. Categories with count less than 2500 are grouped together into "OTHER" category. It has no null values"""

plot_category_percent_of_target(train, 'SkuEdition')

"""No null values are present. No changes needed"""

plot_category_percent_of_target(train, 'IsProtected')

"""We can fill the null values and converted the type to "category""""

plot_category_percent_of_target(train, 'SMode')

"""Smode: This field is set to true when the device is known to be in 'S Mode', as in, Windows 10 S mode, where only Microsoft Store apps can be installed 

The data is imbalanced but we may keep this since SMode may imply more security and can be important to detect malware
"""

plot_category_percent_of_target(train, 'IeVerIdentifier', 50)

"""IeVerIdentifier was coverted to category type and categories with count less than 100 were combined in a single category called "OTHER" """

plot_category_percent_of_target(train, 'SmartScreen')

"""(Off, off), (Warn, warn) , (On, on) can be combined into same category. Categories with count lower than 1000 are grouped together into OTHER"""

plot_category_percent_of_target(train, 'Firewall')

"""Even though Firewall is imbalanced, it may help us detect malware as its related to security of the system."""

train.UacLuaenable.value_counts()

plot_category_percent_of_target(train, 'UacLuaenable')

"""This attribute reports whether or not the "administrator in Admin Approval Mode" user type is disabled or enabled in UAC. So we are not dropping it. 48 and 2 can be grouped together into OTHER category."""

plot_category_percent_of_target(train, 'Census_MDC2FormFactor')

"""Census_MDC2FormFactor was coverted to category type and categories with count less than 1000 were combined in a single category called "PCOther" """

plot_category_percent_of_target(train, 'Census_DeviceFamily')

"""Here Windows Server and Windows are grouped together since Windows has only two values. """

plot_category_percent_of_target(train, 'Census_ProcessorManufacturerIdentifier')

"""Census_ProcessorManufacturerIdentifier was coverted to category type and categories with count less than 100 were combined in a single category called "Other" """

plot_category_percent_of_target(train, 'Census_PrimaryDiskTypeName')

"""We can combine Unknown, Unspecified and Null values into same category"""

plot_category_percent_of_target(train, 'Census_HasOpticalDiskDrive')

"""Converted type to Category. No other change needed."""

plot_category_percent_of_target(train, 'Census_ChassisTypeName', 52)

"""(UNKNOWN, Unknown, Null) can be converted into same category. All categories with count less than 100 are grouped together into OTHER"""

plot_category_percent_of_target(train, 'Census_PowerPlatformRoleName')

"""Combine UNKNOWN and unspeficied into same category. Null values were filled"""

plot_category_percent_of_target(train, 'Census_InternalBatteryType', 25)

"""Not sure how battery would impact whether a system gets malware or not"""

plot_category_percent_of_target(train, 'Census_OSVersion')

"""We can extract different parts of the string to create new features."""

plot_category_percent_of_target(train, 'Census_OSBranch')

"""This was coverted to category type and categories with count less than 1000 were combined in a single category called "Other" """

plot_category_percent_of_target(train, 'Census_OSBuildNumber')

"""This was coverted to category type and categories with count less than 100 were combined in a single category called "Other" """

plot_category_percent_of_target(train, 'Census_OSEdition', 30)

"""We may combine "Core" with other core categories. Same with "professional", "Enterprise","cloud","home" and "server""""

plot_category_percent_of_target(train, "Census_OSInstallTypeName")

"""No changes needed."""

plot_category_percent_of_target(train, 'Census_OSWUAutoUpdateOptionsName')

"""No changes needed."""

plot_category_percent_of_target(train, 'Census_IsPortableOperatingSystem')

"""We may remove this later due to the high imbalance of data"""

plot_category_percent_of_target(train, 'Census_GenuineStateName')

"""Combine "OFFLINE", "UNKNOWN" and "TAMPERED" into "OTHER" Category"""

plot_category_percent_of_target(train, 'Census_ActivationChannel')

"""No changes needed."""

plot_category_percent_of_target(train, 'Census_FlightRing')

"""This was coverted to category type and categories with count less than 10000 were combined in a single category called "Other" """

plot_category_percent_of_target(train, 'Census_ThresholdOptIn')

"""Has high imbalance and should be dropped later."""

plot_category_percent_of_target(train, 'Census_IsSecureBootEnabled')

"""No changes needed."""

plot_category_percent_of_target(train, 'Census_IsVirtualDevice')

"""Imbalanced. May delete this later."""

plot_category_percent_of_target(train, 'Census_IsTouchEnabled')

"""No changes needed."""

plot_category_percent_of_target(train, 'Census_IsPenCapable')

"""No changes needed"""

plot_category_percent_of_target(train, 'Census_IsAlwaysOnAlwaysConnectedCapable')

"""Null values have to be filled. No other changes required. """

plot_category_percent_of_target(train, 'Wdft_IsGamer')

"""Null values have to be filled with 1. No other changes required. """

plot_category_percent_of_target(train, 'Wdft_RegionIdentifier')

"""Convert the dtype into Category

**NOTE: We also need to make sure that all the categorical values present in test dataset are also present in train dataset.**

## Cleaning up train and test dataset
"""

dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'category',
        'IsSxsPassiveMode':                                     'category',
        'DefaultBrowsersIdentifier':                            'category',
        'AVProductStatesIdentifier':                            'category',
        'AVProductsInstalled':                                  'float32',
        'AVProductsEnabled':                                    'category',
        'HasTpm':                                               'category',
        'CountryIdentifier':                                    'category',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'category',
        'GeoNameIdentifier':                                    'category',
        'LocaleEnglishNameIdentifier':                          'category',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'category',
        'OsSuite':                                              'category',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'category',
        'AutoSampleOptIn':                                      'category',
        'PuaMode':                                              'category',
        'SMode':                                                'category',
        'IeVerIdentifier':                                      'category',
        'SmartScreen':                                          'category',
        'Firewall':                                             'category',
        'UacLuaenable':                                         'category',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'category',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float32',
        'Census_ProcessorManufacturerIdentifier':               'category',
        'Census_ProcessorModelIdentifier':                      'category',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'category',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float32',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'category',
        'Census_OSBuildRevision':                               'category',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'category',
        'Census_OSUILocaleIdentifier':                          'category',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'category',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'category',
        'Census_IsFlightsDisabled':                             'category',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'category',
        'Census_FirmwareManufacturerIdentifier':                'category',
        'Census_FirmwareVersionIdentifier':                     'category',
        'Census_IsSecureBootEnabled':                           'category',
        'Census_IsWIMBootEnabled':                              'category',
        'Census_IsVirtualDevice':                               'category',
        'Census_IsTouchEnabled':                                'category',
        'Census_IsPenCapable':                                  'category',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'category',
        'Wdft_IsGamer':                                         'category',
        'Wdft_RegionIdentifier':                                'category',
        'HasDetections':                                        'int8'
        }

train = pd.read_csv(path + "train.csv", dtype=dtypes)
test = pd.read_csv(path + "test.csv", dtype=dtypes)

train = train.drop([
            'MachineIdentifier',
            'IsBeta', 
            'CityIdentifier', 
            'AutoSampleOptIn', 
            'PuaMode', 
            'Census_InternalBatteryType', 
            'Census_InternalBatteryNumberOfCharges', 
            'Census_OSArchitecture',
            'Census_OSSkuName',
            'Census_IsFlightsDisabled'], axis=1)

test = test.drop([
            'IsBeta', 
            'CityIdentifier', 
            'AutoSampleOptIn', 
            'PuaMode', 
            'Census_InternalBatteryType', 
            'Census_InternalBatteryNumberOfCharges', 
            'Census_OSArchitecture',
            'Census_OSSkuName',
            'Census_IsFlightsDisabled'], axis=1)

"""### Combine Categories

As observed in our EDA, there are certain columns where different categories can be combined into one.  So the following function merges those categories together.
"""

def combineCategories(train, test, feature, categoriesToCombine):
    
    numCategories = len(train[feature].cat.categories)

    #We'll just reassign everything to the first category
    firstCategory = categoriesToCombine[0]
    
    for category in categoriesToCombine[1:]:
        train.loc[train[feature] == category, feature] = firstCategory
        test.loc[test[feature] == category, feature] = firstCategory
        
    train[feature] = train[feature].cat.remove_unused_categories();    
    test[feature] = test[feature].cat.remove_unused_categories();

    print("Number of categories before: ", numCategories)
    print("Number of categories after:", len(train[feature].cat.categories))

combineCategories(train, test, 'SmartScreen', ['Off', 'off', 'OFF'])
combineCategories(train, test, 'SmartScreen', ['Warn','warn'])
combineCategories(train, test, 'SmartScreen', ['Prompt','Promt', 'prompt'])
combineCategories(train, test, 'SmartScreen', ['On','on'])
combineCategories(train, test, 'SmartScreen', ['RequireAdmin','requireadmin', 'requireAdmin'])

combineCategories(train, test, 'Census_PrimaryDiskTypeName', ['UNKNOWN','Unspecified'])

combineCategories(train, test, 'Census_PowerPlatformRoleName', ['UNKNOWN', 'Unspecified'])

combineCategories(train, test, 'Census_MDC2FormFactor', ["SmallServer", "MediumServer", "LargeServer", "ServerOther"])

"""### Merge Lower count categories

Since most of the columns are imbalanced and have values that are negligible in count, so we are combining them into a single category called "OTHER"
"""

def replaceLowValueCountsWithOtherCategory(train, test, feature, threshold = 5):
    otherCategory = 'OTHER'

    numCategories = len(train[feature].cat.categories)
    # Add the 'OTHER' category if it doesn't already exist
    if otherCategory not in train[feature].cat.categories:
        train[feature] = train[feature].cat.add_categories(otherCategory)
    if otherCategory not in test[feature].cat.categories:
        test[feature] = test[feature].cat.add_categories(otherCategory)

    # Find all the categories in this feature that don't meet our threshold
    category_selector = train[feature].value_counts() < threshold
    # Assign all the categories that don't meet our threshold to "OTHER"
    train.loc[train[feature].isin((train[feature].value_counts()[category_selector]).index), feature] = otherCategory
    # Remove the unused categories that we grouped into "other" category
    train[feature] = train[feature].cat.remove_unused_categories();

    # Find all missing categores in test set
    missingMask = ~test[feature].cat.categories.isin(train[feature].cat.categories)
    missingCategory = test[feature].cat.categories[missingMask]
    # Assign all missing categories in test set to "OTHER"
    test.loc[test[feature].isin(missingCategory), feature] = otherCategory
    # Remove unused categories    
    test[feature] = test[feature].cat.remove_unused_categories();
    
    #Double check that all of the test features are contained within the training features. 
    assert(test[feature].cat.categories.isin(train[feature].cat.categories).all())
    
    print("Number of categories before: ", numCategories)
    print("Number of categories after:", len(train[feature].cat.categories))

replaceLowValueCountsWithOtherCategory(train, test, 'ProductName', threshold=100)

replaceLowValueCountsWithOtherCategory(train, test, 'EngineVersion', threshold=2500)

replaceLowValueCountsWithOtherCategory(train, test, 'AppVersion', threshold=2500)

replaceLowValueCountsWithOtherCategory(train, test, 'AvSigVersion', threshold=2500)

replaceLowValueCountsWithOtherCategory(train, test, 'AVProductStatesIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'RtpStateBitfield', threshold=3500)

replaceLowValueCountsWithOtherCategory(train, test, 'DefaultBrowsersIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'AVProductsEnabled', threshold=10000)

replaceLowValueCountsWithOtherCategory(train, test, 'OrganizationIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'GeoNameIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'LocaleEnglishNameIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'OsVer', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'OsBuild', threshold=10000)

replaceLowValueCountsWithOtherCategory(train, test, 'OsSuite', threshold=10000)

replaceLowValueCountsWithOtherCategory(train, test, 'OsBuildLab', threshold=2500)

replaceLowValueCountsWithOtherCategory(train, test, 'IeVerIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'SmartScreen', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'UacLuaenable', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OEMNameIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_ProcessorManufacturerIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_ProcessorModelIdentifier', threshold=100)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_ChassisTypeName', threshold=100)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OSBranch', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OSBuildNumber', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OSBuildRevision', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OSEdition', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OSUILocaleIdentifier', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_GenuineStateName', threshold=15000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_FlightRing', threshold=1000)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_FirmwareManufacturerIdentifier', threshold=500)

replaceLowValueCountsWithOtherCategory(train, test, 'Census_FirmwareVersionIdentifier', threshold=500)

test['Census_MDC2FormFactor'].cat.categories

top_cats = list(train['Census_MDC2FormFactor'].value_counts().index[:5])

train['Census_MDC2FormFactor'] = train['Census_MDC2FormFactor'].astype('category')
test['Census_MDC2FormFactor'] = test['Census_MDC2FormFactor'].astype('category')

train.loc[train['Census_MDC2FormFactor'].isin(top_cats) == False, 'Census_MDC2FormFactor'] = 'PCOther'
test.loc[test['Census_MDC2FormFactor'].isin(top_cats) == False, 'Census_MDC2FormFactor'] = 'PCOther'

replaceLowValueCountsWithOtherCategory(train, test, 'Census_OSVersion', threshold=1000)

"""### Replace Other with 0.0.0.0

We will be extracting features from the categories of the following features, so we are giving it a default value '0.0.0.0' instead of OTHER
"""

def replaceOtherWithDef(df,feature,val):
  categories =np.array(df[feature].unique())
  categories=np.delete(categories,np.argwhere(categories=="OTHER"))
  categories=np.append(categories,val)
  df[feature] = pd.Categorical(df[feature], categories=categories)
  df[feature] =df[feature].fillna(val)
  return df

train=replaceOtherWithDef(train,"OsBuildLab","0.0.0.0")
test=replaceOtherWithDef(test,"OsBuildLab","0.0.0.0")

train=replaceOtherWithDef(train,"EngineVersion","0.0.0.0")
test=replaceOtherWithDef(test,"EngineVersion","0.0.0.0")

train=replaceOtherWithDef(train,"AppVersion","0.0.0.0")
test=replaceOtherWithDef(test,"AppVersion","0.0.0.0")

train=replaceOtherWithDef(train,"AvSigVersion","0.0.0.0")
test=replaceOtherWithDef(test,"AvSigVersion","0.0.0.0")

train=replaceOtherWithDef(train,"Census_OSVersion","0.0.0.0")
test=replaceOtherWithDef(test,"Census_OSVersion","0.0.0.0")

"""### Fill null values

We will fill the null values found in the dataset with appropriate values
"""

# if number of antivirus products installed is null, we shall assume its 0
train['AVProductsInstalled'] = train['AVProductsInstalled'].fillna(0)
test['AVProductsInstalled'] = test['AVProductsInstalled'].fillna(0)

# null values are filled with zeros
train['Census_TotalPhysicalRAM'] = np.log(train['Census_TotalPhysicalRAM'])
train.loc[train['Census_PrimaryDiskTotalCapacity'] == 0, 'Census_PrimaryDiskTotalCapacity'] = np.nan
train['Census_PrimaryDiskTotalCapacity'] = np.log(train['Census_PrimaryDiskTotalCapacity'])
train.loc[train['Census_SystemVolumeTotalCapacity'] == 0, 'Census_SystemVolumeTotalCapacity'] = np.nan
train['Census_SystemVolumeTotalCapacity'] = np.log(train['Census_SystemVolumeTotalCapacity'])

test['Census_TotalPhysicalRAM'] = np.log(test['Census_TotalPhysicalRAM'])
test.loc[test['Census_PrimaryDiskTotalCapacity'] == 0, 'Census_PrimaryDiskTotalCapacity'] = np.nan
test['Census_PrimaryDiskTotalCapacity'] = np.log(test['Census_PrimaryDiskTotalCapacity'])
test.loc[test['Census_SystemVolumeTotalCapacity'] == 0, 'Census_SystemVolumeTotalCapacity'] = np.nan
test['Census_SystemVolumeTotalCapacity'] = np.log(test['Census_SystemVolumeTotalCapacity'])

# null values are filled with zeros.
train.Census_OEMModelIdentifier.value_counts(normalize=True, dropna=False).cumsum().head(40)
train['Census_OEMModelIdentifier'] = train['Census_OEMModelIdentifier'].fillna(0)
test['Census_OEMModelIdentifier'] = test['Census_OEMModelIdentifier'].fillna(0)

# if the processorCoreCount is not in (1,2,4,8,16,32), then any other count will be converted to its nearest value. Eg: 38 will be converted to 32
def convertProcessor(df):
  pcount = list(df['Census_ProcessorCoreCount'])
  prange = np.array([1,2,4,8,16,32])

  for i in range(len(pcount)):
    pr = np.absolute(prange - pcount[i])
    indexmin = np.argmin(pr)
    pcount[i] = prange[indexmin]
  
  df['Census_ProcessorCoreCount'] = pcount

convertProcessor(train)
convertProcessor(test)

# Null values of Census_PrimaryDiskTotalCapacity are imputed by the mean value of the feature
train.Census_PrimaryDiskTotalCapacity.value_counts(normalize=True, dropna=False).cumsum().head(40)
mean_Census_PrimaryDiskTotalCapacity=train.Census_PrimaryDiskTotalCapacity.mean()
train['Census_PrimaryDiskTotalCapacity'] = train['Census_PrimaryDiskTotalCapacity'].fillna(mean_Census_PrimaryDiskTotalCapacity)
test['Census_PrimaryDiskTotalCapacity'] = test['Census_PrimaryDiskTotalCapacity'].fillna(mean_Census_PrimaryDiskTotalCapacity)

# Null values of Census_SystemVolumeTotalCapacity are imputed by the mean value of the feature
train.Census_SystemVolumeTotalCapacity.value_counts(normalize=True, dropna=False).cumsum().head(40)
mean_Census_SystemVolumeTotalCapacity=train.Census_SystemVolumeTotalCapacity.mean()
train['Census_SystemVolumeTotalCapacity'] = train['Census_SystemVolumeTotalCapacity'].fillna(mean_Census_SystemVolumeTotalCapacity)
test['Census_SystemVolumeTotalCapacity'] = test['Census_SystemVolumeTotalCapacity'].fillna(mean_Census_SystemVolumeTotalCapacity)

# As mentioned in EDA, since various RAM sizes are present and we are categorizing this, instead of grouping lower count categories together, we add them to the nearest bucket 
def convertRamsizes(df):
  pcount = list(df['Census_TotalPhysicalRAM'])
  prange = np.array([512,1024,2048,4096,8192,16*1024,32*1024,65536])

  for i in range(len(pcount)):
    pr = np.absolute(prange - pcount[i])
    indexmin = np.argmin(pr)
    pcount[i] = prange[indexmin]
  
  df['Census_TotalPhysicalRAM'] = pcount

convertRamsizes(train)
convertRamsizes(test)

# Null values of Census_InternalPrimaryDiagonalDisplaySizeInInches are imputed by the mean value of the feature
train.Census_InternalPrimaryDiagonalDisplaySizeInInches.value_counts(normalize=True, dropna=False).cumsum().head(40)
mean_IPDDSII=train.Census_InternalPrimaryDiagonalDisplaySizeInInches.mean()
train['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = train['Census_InternalPrimaryDiagonalDisplaySizeInInches'].fillna(mean_IPDDSII)
test['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = test['Census_InternalPrimaryDiagonalDisplaySizeInInches'].fillna(mean_IPDDSII)

# As mentioned in EDA, since various resolutions are present and we are categorizing this, instead of grouping lower count categories together, we add them to the nearest bucket 
def convertResolution(df):
  pcount = list(df['Census_InternalPrimaryDisplayResolutionHorizontal'])
  prange = np.array([1024,1280,1366,1440,1600,1920,2560,3440])

  for i in range(len(pcount)):
    pr = np.absolute(prange - pcount[i])
    indexmin = np.argmin(pr)
    pcount[i] = prange[indexmin]
  
  df['Census_InternalPrimaryDisplayResolutionHorizontal'] = pcount

def convertResolutionV(df):
  pcount = list(df['Census_InternalPrimaryDisplayResolutionVertical'])
  prange = np.array([540,768,900,1080,1200,1440,2048])

  for i in range(len(pcount)):
    pr = np.absolute(prange - pcount[i])
    indexmin = np.argmin(pr)
    pcount[i] = prange[indexmin]
  
  df['Census_InternalPrimaryDisplayResolutionVertical'] = pcount

convertResolution(train)
convertResolution(test)

convertResolutionV(train)
convertResolutionV(test)

"""### Feature Engineering

We have referred different forums and public notebooks to engineer more features.
"""

# the following categories are in the form X.X.X.X 
# more features can be extracted from the different parts of the string in these categories

def extract_data(data):   
    data['OsBuildLab_exact'] = data['OsBuildLab'].apply(lambda x: x.split('.')[0] +'.'+ x.split('.')[1])
    data['OsBuildLab_exact'] = data['OsBuildLab_exact'].astype('category')
    
    data['EngineVersion_2'] = data['EngineVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    data['EngineVersion_3'] = data['EngineVersion'].apply(lambda x: x.split('.')[3]).astype('category')
    
    data['AppVersion_1'] = data['AppVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    data['AppVersion_2'] = data['AppVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    data['AppVersion_3'] = data['AppVersion'].apply(lambda x: x.split('.')[3]).astype('category')
    
    data['AvSigVersion_0'] = data['AvSigVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    data['AvSigVersion_1'] = data['AvSigVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    data['AvSigVersion_2'] = data['AvSigVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    
    data['OsBuildLab_0'] = data['OsBuildLab'].apply(lambda x: x.split('.')[0]).astype('category')
    data['OsBuildLab_1'] = data['OsBuildLab'].apply(lambda x: x.split('.')[1]).astype('category')
    data['OsBuildLab_2'] = data['OsBuildLab'].apply(lambda x: x.split('.')[2]).astype('category')
    data['OsBuildLab_3'] = data['OsBuildLab'].apply(lambda x: x.split('.')[3]).astype('category')
    
    data['Census_OSVersion_0'] = data['Census_OSVersion'].apply(lambda x: x.split('.')[0]).astype('category')
    data['Census_OSVersion_1'] = data['Census_OSVersion'].apply(lambda x: x.split('.')[1]).astype('category')
    data['Census_OSVersion_2'] = data['Census_OSVersion'].apply(lambda x: x.split('.')[2]).astype('category')
    data['Census_OSVersion_3'] = data['Census_OSVersion'].apply(lambda x: x.split('.')[3]).astype('category')
    return data

# New features created from numeric data
def featureEngineering(df):
    df = extract_data(df)
    df['HighRam'] = df['Census_TotalPhysicalRAM'] > 16384
    df['LowSystemDisk'] = df['Census_SystemVolumeTotalCapacity'] > 30000.0
    df['LowDisk'] = df['Census_PrimaryDiskTotalCapacity'] > 16384
    df['primary_drive_c_ratio'] = df['Census_SystemVolumeTotalCapacity']/ df['Census_PrimaryDiskTotalCapacity']
    df['non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']
    df['aspect_ratio'] = df['Census_InternalPrimaryDisplayResolutionHorizontal']/ df['Census_InternalPrimaryDisplayResolutionVertical']
    df['dpi'] = ((df['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + df['Census_InternalPrimaryDisplayResolutionVertical']**2)**.5)/(df['Census_InternalPrimaryDiagonalDisplaySizeInInches'])
    df['dpi_square'] = df['dpi'] ** 2
    df['MegaPixels'] = (df['Census_InternalPrimaryDisplayResolutionHorizontal'] * df['Census_InternalPrimaryDisplayResolutionVertical'])/1e6
    df['Screen_Area'] = (df['aspect_ratio']* (df['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2))/(df['aspect_ratio']**2 + 1)
    df['ram_per_processor'] = df['Census_TotalPhysicalRAM']/ df['Census_ProcessorCoreCount']
    df['new_num_0'] = df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] / df['Census_ProcessorCoreCount']
    df['new_num_1'] = df['Census_ProcessorCoreCount'] * df['Census_InternalPrimaryDiagonalDisplaySizeInInches']
    return df

train = featureEngineering(train)
test = featureEngineering(test)

train.head(5)

"""### Encoding

We performed frequency encoding, followed by label encoding for these categorical columns
"""

# Find the list of categorical columns and numeric columns
cols = train.columns
num_cols = train._get_numeric_data().columns
cat_cols = list(set(cols) - set(num_cols))

# features which have more than 1000 unique values will be frequency encoded
to_encode = []
for col in cat_cols:
    if train[col].nunique() > 1000:
        print(col, train[col].nunique())
        to_encode.append(col)

# Label encoding for categorical columns : a unique index is assigned for each category
indexer = {}
for col in cat_cols:
    _, indexer[col] = pd.factorize(train[col].astype(str), sort=True)

for col in cat_cols:
    train[col] = indexer[col].get_indexer(train[col].astype(str))
    test[col] = indexer[col].get_indexer(test[col].astype(str))

# selecting the final columns
x_columns = ['ProductName', 'EngineVersion', 'AppVersion', 'AvSigVersion',
       'RtpStateBitfield', 'IsSxsPassiveMode', 'DefaultBrowsersIdentifier',
       'AVProductStatesIdentifier', 'AVProductsInstalled', 'AVProductsEnabled',
       'HasTpm', 'CountryIdentifier', 'OrganizationIdentifier',
       'GeoNameIdentifier', 'LocaleEnglishNameIdentifier', 'Platform',
       'Processor', 'OsVer', 'OsBuild', 'OsSuite', 'OsPlatformSubRelease',
       'OsBuildLab', 'SkuEdition', 'IsProtected', 'SMode', 'IeVerIdentifier',
       'SmartScreen', 'Firewall', 'UacLuaenable', 'Census_MDC2FormFactor',
       'Census_DeviceFamily', 'Census_OEMNameIdentifier',
       'Census_OEMModelIdentifier', 'Census_ProcessorCoreCount',
       'Census_ProcessorManufacturerIdentifier',
       'Census_ProcessorModelIdentifier', 'Census_ProcessorClass',
       'Census_PrimaryDiskTotalCapacity', 'Census_PrimaryDiskTypeName',
       'Census_SystemVolumeTotalCapacity', 'Census_HasOpticalDiskDrive',
       'Census_TotalPhysicalRAM', 'Census_ChassisTypeName',
       'Census_InternalPrimaryDiagonalDisplaySizeInInches',
       'Census_InternalPrimaryDisplayResolutionHorizontal',
       'Census_InternalPrimaryDisplayResolutionVertical',
       'Census_PowerPlatformRoleName', 'Census_OSVersion', 'Census_OSBranch',
       'Census_OSBuildNumber', 'Census_OSBuildRevision', 'Census_OSEdition',
       'Census_OSInstallTypeName', 'Census_OSInstallLanguageIdentifier',
       'Census_OSUILocaleIdentifier', 'Census_OSWUAutoUpdateOptionsName',
       'Census_IsPortableOperatingSystem', 'Census_GenuineStateName',
       'Census_ActivationChannel', 'Census_IsFlightingInternal',
       'Census_FlightRing', 'Census_ThresholdOptIn',
       'Census_FirmwareManufacturerIdentifier',
       'Census_FirmwareVersionIdentifier', 'Census_IsSecureBootEnabled',
       'Census_IsWIMBootEnabled', 'Census_IsVirtualDevice',
       'Census_IsTouchEnabled', 'Census_IsPenCapable',
       'Census_IsAlwaysOnAlwaysConnectedCapable', 'Wdft_IsGamer',
       'Wdft_RegionIdentifier', 'HighRam', 'LowSystemDisk',
       'LowDisk', 'primary_drive_c_ratio', 'non_primary_drive_MB',
       'aspect_ratio', 'dpi', 'dpi_square', 'MegaPixels', 'Screen_Area',
       'ram_per_processor', 'new_num_0', 'new_num_1']

# x for test set
test_x = test[x_columns]

# x and y for train set
data_x = train[x_columns]
data_y = train['HasDetections']

trainforindex=train[x_columns]

train.head()

"""## Final Model"""

import pandas as pd
import numpy as np
import lightgbm as lgb

#import xgboost as xgb
from scipy.sparse import vstack, csr_matrix, save_npz, load_npz
from sklearn.model_selection import StratifiedKFold, KFold
from sklearn.preprocessing import OneHotEncoder, LabelEncoder
from sklearn import feature_selection
from sklearn import model_selection
from sklearn import metrics
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.utils import check_array
from scipy import sparse

# Scalers
from sklearn.preprocessing import StandardScaler
from sklearn.utils import shuffle
from sklearn.pipeline import Pipeline
from sklearn.pipeline import FeatureUnion
import gc

gc.enable()

train_ids = trainforindex.index
test_ids = test.index

import lightgbm as lgb
from sklearn.metrics import confusion_matrix, roc_auc_score ,roc_curve,auc
from sklearn.linear_model import LogisticRegression
# MODEL : LGBM with Stratified K folds
kf = StratifiedKFold(n_splits=5,shuffle=True,random_state=20)
pred_test_full =0
cv_score =[]
i=1

oof_1= np.zeros(train_ids.shape[0])
for train_index,test_index in kf.split(data_x,data_y):
  print('{} of KFold {}'.format(i,kf.n_splits))

  xtr,xvl = data_x.iloc[train_index],data_x.iloc[test_index]
  ytr,yvl = data_y.iloc[train_index],data_y.iloc[test_index]


  lgb_model = lgb.LGBMClassifier(max_depth=8,
                  n_estimators=30000,
                  learning_rate=0.05,
                  num_leaves=2**12-1,
                  colsample_bytree=0.28,
                  objective='binary',
                  n_jobs=-1)

  lgb_model.fit(xtr, ytr, eval_metric='auc',
         eval_set=[(xvl, yvl)],
         verbose=100, early_stopping_rounds=100)

  oof_1[test_index] += lgb_model.predict_proba(xvl)[:,1]

  score = roc_auc_score(yvl,lgb_model.predict(xvl))
  print('ROC AUC score:',score)
  pred_test = lgb_model.predict_proba(test_x)[:,1]
  pred_test_full +=pred_test
  i+=1

#saving the predictions
submission = pd.read_csv(path+'sample_submission.csv')
submission['HasDetections'] = (pred_test_full / 5)
submission.to_csv('Neha_owntrial_KFold_check.csv', index=False)